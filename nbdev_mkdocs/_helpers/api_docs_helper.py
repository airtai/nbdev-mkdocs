# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/API_Docs_Helper.ipynb.

# %% auto 0
__all__ = ['ParameterKindMapper', 'get_formatted_docstring_for_symbol']

# %% ../../nbs/API_Docs_Helper.ipynb 1
from typing import *
import types
import enum
import re
from inspect import Signature, signature, isfunction, isclass, getmembers, getdoc

from griffe.dataclasses import Docstring, Function, Parameters, Parameter, ParameterKind
from griffe.docstrings.parsers import Parser, parse
from griffe.expressions import Expression, Name

from mkdocstrings_handlers.python.handler import get_handler, PythonHandler
from markdown.core import Markdown

# %% ../../nbs/API_Docs_Helper.ipynb 2
def _convert_union_to_optional(annotation_str: str) -> str:
    """Convert the 'Union[Type1, Type2, ..., NoneType]' to 'Optional[Type1, Type2, ...]' in the given annotation string

    Args:
        annotation_str: The type annotation string to convert.

    Returns:
        The converted type annotation string.
    """
    pattern = r"Union\[(.*)?,\s*NoneType\s*\]"
    match = re.search(pattern, annotation_str)
    if match:
        union_type = match.group(1)
        optional_type = f"Optional[{union_type}]"
        return re.sub(pattern, optional_type, annotation_str)
    else:
        return annotation_str

# %% ../../nbs/API_Docs_Helper.ipynb 4
def _get_arg_list_with_signature(
    _signature: Signature, return_as_list: bool = False
) -> Union[str, List[str]]:
    """Converts a function's signature into a string representation of its argument list.

    Args:
        _signature (signature): The signature object for the function to convert.

    Returns:
        str: A string representation of the function's argument list.
    """
    arg_list = []
    for param in _signature.parameters.values():
        arg_list.append(_convert_union_to_optional(str(param)))

    return arg_list if return_as_list else ", ".join(arg_list)

# %% ../../nbs/API_Docs_Helper.ipynb 6
def _get_return_annotation(sig: Signature, symbol_definition: str) -> str:
    if sig.return_annotation and "inspect._empty" not in str(sig.return_annotation):
        if isinstance(sig.return_annotation, type):
            symbol_definition = (
                symbol_definition + f" -> {sig.return_annotation.__name__}\n"
            )
        else:
            symbol_definition = symbol_definition + f" -> {sig.return_annotation}\n"
            symbol_definition = symbol_definition.replace("typing.", "")

    else:
        symbol_definition = symbol_definition + " -> None\n"
    return symbol_definition

# %% ../../nbs/API_Docs_Helper.ipynb 8
def _get_symbol_definition(symbol: Union[types.FunctionType, Type[Any]]) -> str:
    """Return the definition of a given symbol.

    Args:
        symbol: A function or method object to get the definition for.

    Returns:
        A string representing the function definition
    """
    _signature = signature(symbol)
    arg_list = _get_arg_list_with_signature(_signature)
    ret_val = ""

    if isfunction(symbol):
        ret_val = ret_val + f"`def {symbol.__name__}({arg_list})"
        ret_val = _get_return_annotation(_signature, ret_val) + "`"

    return ret_val

# %% ../../nbs/API_Docs_Helper.ipynb 10
def _get_sample_markdown_handler_config() -> Markdown:
    md_config = Markdown(extensions=["toc"], extension_configs={})
    return md_config

# %% ../../nbs/API_Docs_Helper.ipynb 12
def _get_handler(md_config: Markdown) -> PythonHandler:
    handler = get_handler(theme="material")
    handler._update_env(md_config, {"mdx": [], "mdx_configs": []})
    return handler

# %% ../../nbs/API_Docs_Helper.ipynb 14
class ParameterKindMapper(enum.Enum):
    POSITIONAL_ONLY: ParameterKind = ParameterKind.positional_only
    POSITIONAL_OR_KEYWORD: ParameterKind = ParameterKind.positional_or_keyword
    VAR_POSITIONAL: ParameterKind = ParameterKind.var_positional
    KEYWORD_ONLY: ParameterKind = ParameterKind.keyword_only
    VAR_KEYWORD: ParameterKind = ParameterKind.var_keyword

# %% ../../nbs/API_Docs_Helper.ipynb 16
def _get_function_parameters(
    symbol: Union[types.FunctionType, Type[Any]]
) -> Parameters:
    sig = signature(symbol)
    params = [param for param in sig.parameters.values()]
    return Parameters(
        *[
            Parameter(
                param.name,
                annotation=Name(
                    source=str(sig.parameters[param.name])
                    .split(": ")[1]
                    .split(" =")[0],
                    full=str(sig.parameters[param.name]).split(": ")[1].split(" =")[0],
                )
                if param.annotation is not param.empty
                else None,
                default="{}"
                if param.name == "kwargs"
                else None
                if param.default is param.empty
                else str(param.default),
                kind=ParameterKindMapper[param.kind.name].value,
            )
            for param in params
        ]
    )

# %% ../../nbs/API_Docs_Helper.ipynb 18
def _get_func_object_for_symbol(symbol):
    function = Function(
        symbol.__name__, parameters=_get_function_parameters(symbol)
    )  # todo: add returns and decorators
    return function

# %% ../../nbs/API_Docs_Helper.ipynb 20
def _generate_markup_for_docstring_section(section, handler: PythonHandler) -> str:
    template = handler.env.get_template(f"docstring/{section.kind.value}.html")
    rendered_html = template.render(section=section, config=handler.default_config)
    return f"{rendered_html}\n"


def _docstring_to_markdown(symbol: Union[types.FunctionType, Type[Any]]) -> str:
    """Converts a docstring to a markdown-formatted string.

    Args:
        docstring: The docstring to convert.

    Returns:
        The markdown-formatted docstring.
    """
    #     docstring = Docstring(symbol.__doc__)  # type: ignore
    function = _get_func_object_for_symbol(symbol)
    docstring = Docstring(getdoc(symbol), parent=function)  # type: ignore
    parsed_docstring_sections = parse(docstring, Parser.google)

    md_config = _get_sample_markdown_handler_config()
    handler = _get_handler(md_config)

    ret_val = [
        f"{section.value}\n"
        if section.kind.value == "text"
        else _generate_markup_for_docstring_section(section, handler)
        for section in parsed_docstring_sections
    ]

    return "".join(ret_val)

# %% ../../nbs/API_Docs_Helper.ipynb 22
def get_formatted_docstring_for_symbol(
    symbol: Union[types.FunctionType, Type[Any]]
) -> str:
    """Recursively parses and get formatted docstring of a symbol.

    Args:
        symbol: A Python class or function object to parse the docstring for.

    Returns:
        A formatted docstring of the symbol and its members.

    """

    def traverse(symbol: Union[types.FunctionType, Type[Any]], contents: str) -> str:
        """Recursively traverse the members of a symbol and append their docstrings to the provided contents string.

        Args:
            symbol: A Python class or function object to parse the docstring for.
            contents: The current formatted docstrings.

        Returns:
            The updated formatted docstrings.

        """
        for x, y in getmembers(symbol):
            if not x.startswith("_") or x == "__init__":
                if isfunction(y) and y.__doc__ is not None:
                    contents += (
                        f"{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                    )
                elif isclass(y) and not x.startswith("__") and y.__doc__ is not None:
                    contents += (
                        f"{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                    )
                    contents = traverse(y, contents)
        return contents

    contents = (
        f"{_get_symbol_definition(symbol)}\n\n{_docstring_to_markdown(symbol)}"
        if symbol.__doc__ is not None
        else ""
    )
    if isclass(symbol):
        contents = traverse(symbol, contents)
    return contents
