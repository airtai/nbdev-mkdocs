# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/API_Docs_Helper.ipynb.

# %% auto 0
__all__ = ['get_formatted_docstring_for_symbol']

# %% ../../nbs/API_Docs_Helper.ipynb 1
from typing import *
import types
import re
from inspect import Signature, signature, isfunction, isclass, getmembers

from griffe.dataclasses import Docstring
from griffe.docstrings.parsers import Parser, parse

from mkdocstrings_handlers.python.handler import get_handler, PythonHandler
from markdown.core import Markdown

# %% ../../nbs/API_Docs_Helper.ipynb 2
def _convert_union_to_optional(annotation_str: str) -> str:
    """Convert the 'Union[Type1, Type2, ..., NoneType]' to 'Optional[Type1, Type2, ...]' in the given annotation string

    Args:
        annotation_str: The type annotation string to convert.

    Returns:
        The converted type annotation string.
    """
    pattern = r"Union\[(.*)?,\s*NoneType\s*\]"
    match = re.search(pattern, annotation_str)
    if match:
        union_type = match.group(1)
        optional_type = f"Optional[{union_type}]"
        return re.sub(pattern, optional_type, annotation_str)
    else:
        return annotation_str

# %% ../../nbs/API_Docs_Helper.ipynb 4
def _get_arg_list_with_signature(
    _signature: Signature, return_as_list: bool = False
) -> Union[str, List[str]]:
    """Converts a function's signature into a string representation of its argument list.

    Args:
        _signature (signature): The signature object for the function to convert.

    Returns:
        str: A string representation of the function's argument list.
    """
    arg_list = []
    for param in _signature.parameters.values():
        arg_list.append(_convert_union_to_optional(str(param)))

    return arg_list if return_as_list else ", ".join(arg_list)

# %% ../../nbs/API_Docs_Helper.ipynb 6
def _get_return_annotation(sig: Signature, symbol_definition: str) -> str:
    if sig.return_annotation and "inspect._empty" not in str(sig.return_annotation):
        if isinstance(sig.return_annotation, type):
            symbol_definition = (
                symbol_definition + f" -> {sig.return_annotation.__name__}\n"
            )
        else:
            symbol_definition = symbol_definition + f" -> {sig.return_annotation}\n"
            symbol_definition = symbol_definition.replace("typing.", "")

    else:
        symbol_definition = symbol_definition + " -> None\n"
    return symbol_definition

# %% ../../nbs/API_Docs_Helper.ipynb 8
def _get_symbol_definition(symbol: Union[types.FunctionType, Type[Any]]) -> str:
    """Return the definition of a given symbol.

    Args:
        symbol: A function or method object to get the definition for.

    Returns:
        A string representing the function definition
    """
    _signature = signature(symbol)
    arg_list = _get_arg_list_with_signature(_signature)
    ret_val = ""

    if isfunction(symbol):
        ret_val = ret_val + f"`def {symbol.__name__}({arg_list})"
        ret_val = _get_return_annotation(_signature, ret_val) + "`"

    return ret_val

# %% ../../nbs/API_Docs_Helper.ipynb 10
def _get_sample_markdown_handler_config() -> Markdown:
    md_config = Markdown(extensions=["toc"], extension_configs={})
    return md_config

# %% ../../nbs/API_Docs_Helper.ipynb 12
def _get_handler(md_config: Markdown) -> PythonHandler:
    handler = get_handler(theme="material")
    handler._update_env(md_config, {"mdx": [], "mdx_configs": []})
    return handler

# %% ../../nbs/API_Docs_Helper.ipynb 14
def _docstring_to_markdown(symbol: Union[types.FunctionType, Type[Any]]) -> str:
    """Converts a docstring to a markdown-formatted string.

    Args:
        docstring: The docstring to convert.

    Returns:
        The markdown-formatted docstring.
    """
    docstring = Docstring(symbol.__doc__)  # type: ignore
    parsed_docstring_sections = parse(docstring, Parser.google)

    md_config = _get_sample_markdown_handler_config()
    handler = _get_handler(md_config)

    formatted_docstring = ""
    for section in parsed_docstring_sections:
        if section.kind.value == "text":
            formatted_docstring += f"{section.value}\n\n"  # type: ignore
        else:
            template = handler.env.get_template(f"docstring/{section.kind.value}.html")
            rendered_html = template.render(
                section=section, config=handler.default_config
            )
            formatted_docstring += f"{rendered_html}\n\n"

    return formatted_docstring

# %% ../../nbs/API_Docs_Helper.ipynb 16
def get_formatted_docstring_for_symbol(
    symbol: Union[types.FunctionType, Type[Any]]
) -> str:
    """Recursively parses and get formatted docstring of a symbol.

    Args:
        symbol: A Python class or function object to parse the docstring for.

    Returns:
        A formatted docstring of the symbol and its members.

    """

    def traverse(symbol: Union[types.FunctionType, Type[Any]], contents: str) -> str:
        """Recursively traverse the members of a symbol and append their docstrings to the provided contents string.

        Args:
            symbol: A Python class or function object to parse the docstring for.
            contents: The current formatted docstrings.

        Returns:
            The updated formatted docstrings.

        """
        for x, y in getmembers(symbol):
            if not x.startswith("_") or x == "__init__":
                if isfunction(y) and y.__doc__ is not None:
                    contents += (
                        f"{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                    )
                elif isclass(y) and not x.startswith("__") and y.__doc__ is not None:
                    contents += (
                        f"{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                    )
                    contents = traverse(y, contents)
        return contents

    contents = (
        f"{_get_symbol_definition(symbol)}\n\n{_docstring_to_markdown(symbol)}"
        if symbol.__doc__ is not None
        else ""
    )
    if isclass(symbol):
        contents = traverse(symbol, contents)
    return contents
