# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/API_Docs_Helper.ipynb.

# %% auto 0
__all__ = ['ParameterKindMapper', 'get_formatted_docstring_for_symbol']

# %% ../../nbs/API_Docs_Helper.ipynb 1
from typing import *
import types
import enum
import re
import ast
import textwrap
from pathlib import Path
from ast import ClassDef, FunctionDef, alias, ImportFrom
from inspect import (
    Signature,
    signature,
    isfunction,
    isclass,
    getmembers,
    getdoc,
    getsource,
    getsourcefile,
)
from importlib import import_module

import griffe
from griffe.dataclasses import (
    Docstring,
    Function,
    Parameters,
    Parameter,
    ParameterKind,
    Module,
    Class,
)
from griffe.docstrings.parsers import Parser, parse
from griffe.expressions import Expression, Name
from griffe.agents.nodes import get_annotation, relative_to_absolute
from griffe.exceptions import BuiltinModuleError

from mkdocstrings_handlers.python.handler import get_handler, PythonHandler
from markdown.core import Markdown

from nbdev.config import get_config


import typer

# %% ../../nbs/API_Docs_Helper.ipynb 3
def _get_sample_markdown_handler_config() -> Markdown:
    md_config = Markdown(
        extensions=["toc"],
        extension_configs={},
    )
    return md_config

# %% ../../nbs/API_Docs_Helper.ipynb 5
def _get_handler(md_config: Markdown) -> PythonHandler:
    handler = get_handler(
        theme="material",
    )
    handler._update_env(
        md_config, {"mdx": [], "mdx_configs": []}
    )  # check what config i need to pass
    return handler

# %% ../../nbs/API_Docs_Helper.ipynb 7
class ParameterKindMapper(enum.Enum):
    POSITIONAL_ONLY: ParameterKind = ParameterKind.positional_only
    POSITIONAL_OR_KEYWORD: ParameterKind = ParameterKind.positional_or_keyword
    VAR_POSITIONAL: ParameterKind = ParameterKind.var_positional
    KEYWORD_ONLY: ParameterKind = ParameterKind.keyword_only
    VAR_KEYWORD: ParameterKind = ParameterKind.var_keyword

# %% ../../nbs/API_Docs_Helper.ipynb 9
def _get_symbol_filepath(symbol) -> Path:
    config = get_config()
    filepath = getsourcefile(symbol)
    return Path(filepath).relative_to(
        filepath.split(f'{config["lib_name"].replace("-", "_")}/')[0]
    )

# %% ../../nbs/API_Docs_Helper.ipynb 12
def _get_module_source(module_name: str) -> str:
    m = import_module(module_name)
    return getsource(m)


def _get_absolute_module_import_path(
    symbol: Union[types.FunctionType, Type[Any]]
) -> Dict[str, str]:
    m_source = _get_module_source(symbol.__module__)
    tree = ast.parse(m_source)
    filepath = _get_symbol_filepath(symbol)
    name = ".".join(symbol.__module__.split(".")[:-1])
    current_module = Module(name=name, filepath=Path(filepath))
    return {
        name.name: relative_to_absolute(node, name, current_module)
        for node in tree.body
        if isinstance(node, ImportFrom)
        for name in node.names
    }

# %% ../../nbs/API_Docs_Helper.ipynb 15
def _fix_abs_import_path(
    annotated_args: Dict[str, Any], abs_import_path: Dict[str, str]
) -> Dict[str, Any]:
    return {
        key: (
            Name(source=annotated_args[key].source, full=abs_import_path[val.full])
            if (isinstance(val, Name)) and (val.full in abs_import_path.keys())
            else val
        )
        for key, val in annotated_args.items()
    }

# %% ../../nbs/API_Docs_Helper.ipynb 17
def _flattern(xs: List[Any]) -> List[Any]:
    return [subitem for item in xs if isinstance(item, list) for subitem in item] + [
        item for item in xs if not isinstance(item, list)
    ]


def _get_init_node(node: ClassDef) -> Optional[FunctionDef]:
    init_node = [
        n for n in node.body if isinstance(n, FunctionDef) and n.name == "__init__"
    ]
    if len(init_node) == 0:
        return None
    return init_node[0]


def _get_annotation_for_all_params(
    symbol: Union[types.FunctionType, Type[Any]]
) -> Dict[str, Any]:
    source = getsource(symbol)
    tree = ast.parse(textwrap.dedent(source))
    name = ".".join(symbol.__module__.split(".")[:-1])
    parent = Module(
        #         name=symbol.__module__,
        #         name=symbol.__name__,
        name=name,
        #         filepath=symbol.__module__ + "." + symbol.__name__,
    )
    node = (
        _get_init_node(tree.body[0])
        if isinstance(tree.body[0], ClassDef)
        else tree.body[0]
    )

    if node is None:
        return {}

    args_list = {
        key: value
        for key, value in node.args.__dict__.items()  # type: ignore
        if key not in ["defaults", "kw_defaults"]
    }
    args = [arg for arg in args_list.values() if arg and arg != [None]]
    annotated_args = {
        arg.arg: get_annotation(arg.annotation, parent) for arg in _flattern(args)
    }
    abs_import_path = _get_absolute_module_import_path(symbol)
    return _fix_abs_import_path(annotated_args, abs_import_path)

# %% ../../nbs/API_Docs_Helper.ipynb 26
def _get_function_parameters(
    symbol: Union[types.FunctionType, Type[Any]]
) -> Optional[Parameters]:
    sig = signature(symbol)
    params = [param for param in sig.parameters.values()]
    annotations = _get_annotation_for_all_params(symbol)
    parameters = [
        Parameter(
            param.name,
            annotation=annotations[param.name],
            default="{}"
            if param.name == "kwargs"
            else None
            if param.default is param.empty
            else str(param.default),
            kind=ParameterKindMapper[param.kind.name].value,
        )
        for param in params
    ]
    if len(parameters) == 0:
        return None
    return Parameters(*parameters)

# %% ../../nbs/API_Docs_Helper.ipynb 29
def _get_object_for_symbol(
    symbol: Union[types.FunctionType, Type[Any]]
) -> Union[Class, Function]:
    if isfunction(symbol):
        return Function(
            symbol.__name__, parameters=_get_function_parameters(symbol)
        )  # todo: add returns and decorators
    return Class(symbol.__name__)

# %% ../../nbs/API_Docs_Helper.ipynb 32
def _generate_markup_for_docstring_section(section: Any, handler: PythonHandler) -> str:
    template = handler.env.get_template(f"docstring/{section.kind.value}.html")
    rendered_html = template.render(section=section, config=handler.default_config)
    return f"{rendered_html}\n"


def _docstring_to_markdown(symbol: Union[types.FunctionType, Type[Any]]) -> str:
    """Converts a docstring to a markdown-formatted string.

    Args:
        symbol: The symbol for which the docstring needs to be converted.

    Returns:
        The markdown-formatted docstring.
    """
    parent = _get_object_for_symbol(symbol)
    docstring = Docstring(getdoc(symbol), parent=parent)  # type: ignore
    parsed_docstring_sections = parse(docstring, Parser.google)

    md_config = _get_sample_markdown_handler_config()
    handler = _get_handler(md_config)

    ret_val = [
        f"{section.value}\n"  # type: ignore
        if section.kind.value == "text"
        else _generate_markup_for_docstring_section(section, handler)
        for section in parsed_docstring_sections
    ]

    return "".join(ret_val)

# %% ../../nbs/API_Docs_Helper.ipynb 34
def _get_annotated_symbol_definition(symbol):
    try:
        module = f"{symbol.__module__}.{symbol.__qualname__}"
        griffe.load(module)
        return f"\n\n::: {module}"
    except KeyError as e:
        patched_symbol_path = _get_symbol_filepath(symbol)
        return f"\n\n::: {str(patched_symbol_path.parent)}.{str(patched_symbol_path.stem)}.{symbol.__name__}"


def get_formatted_docstring_for_symbol(
    symbol: Union[types.FunctionType, Type[Any]]
) -> str:
    """Recursively parses and get formatted docstring of a symbol.

    Args:
        symbol: A Python class or function object to parse the docstring for.

    Returns:
        A formatted docstring of the symbol and its members.

    """

    def traverse(symbol: Union[types.FunctionType, Type[Any]], contents: str) -> str:
        """Recursively traverse the members of a symbol and append their docstrings to the provided contents string.

        Args:
            symbol: A Python class or function object to parse the docstring for.
            contents: The current formatted docstrings.

        Returns:
            The updated formatted docstrings.

        """
        for x, y in getmembers(symbol):
            if not x.startswith("_") or x == "__init__":
                if isfunction(y) and y.__doc__ is not None:
                    contents += f"\n\n{_get_annotated_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                #                     contents += f"\n\n::: {symbol.__module__}.{symbol.__name__}.{y.__name__}\n\n{_docstring_to_markdown(y)}"
                #                     contents += f"\n\n{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                #                     contents += f"{_docstring_to_markdown(y)}"
                elif isclass(y) and not x.startswith("__") and y.__doc__ is not None:
                    #                     contents += f"{_get_symbol_definition(y)}\n\n{_docstring_to_markdown(y)}"
                    contents += f"{_docstring_to_markdown(y)}"
                    contents = traverse(y, contents)
        return contents

    contents = (
        #         f"{_get_symbol_definition(symbol)}\n\n{_docstring_to_markdown(symbol)}"
        f"{_docstring_to_markdown(symbol)}"
        if symbol.__doc__ is not None
        else ""
    )
    if isclass(symbol):
        contents = traverse(symbol, contents)

    contents = f"::: {symbol.__module__}.{symbol.__name__}\n\n{contents}"
    return contents
